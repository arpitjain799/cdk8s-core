import { execFileSync } from 'child_process';
import * as path from 'path';
import { Token, Stack, CfnResource } from 'aws-cdk-lib';
import { Lazy } from './lazy';

export function resolve(value: any, stack?: Stack): any {

  if (value == null) {
    return value;
  }

  // cdk8s token
  if (value instanceof Lazy) {
    const resolved = value.produce();
    return resolve(resolved, stack);
  }

  if (stack && Token.isUnresolved(value)) {
    const resolved = stack.resolve(value);
    const token = parseAwsCdkToken(resolved);
    try {
      return fetchAwsCdkTokenValue(token, stack);
    } catch (error) {
      // maybe the CDK deployment didn't happen yet
      return value;
    }
  }

  // implicit token as generated by the cdk8s-cli (e.g IntOrString)
  if (typeof(value.resolve) === 'function') {
    const resolved = value.resolve();
    return resolve(resolved, stack);
  }

  if (typeof(value) !== 'object') {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(x => resolve(x, stack));
  }

  const result: any = {};

  for (const [k, v] of Object.entries(value)) {
    result[k] = resolve(v, stack);
  }

  return result;

}

interface AwsCdkToken {
  readonly logicalId: string;
  readonly attribute: string;
}

function parseAwsCdkToken(resolved: any): AwsCdkToken {
  const keys = Object.keys(resolved);
  if (keys.length > 1) {
    throw Error(`Token must only have 1 key: ${JSON.stringify(resolved)}`);
  }
  const key = keys[0];
  if (key === 'Ref') {
    return {
      attribute: key,
      logicalId: resolved[key],
    };
  }
  if (key === 'Fn::GetAtt') {
    const value = resolved[keys[0]];
    // TODO validate this is indeed an array of size 2
    return {
      attribute: value[1],
      logicalId: value[0],
    };
  }
  throw new Error(`Unexpected token: ${JSON.stringify(resolved)}`);
}

function fetchAwsCdkTokenValue(token: AwsCdkToken, stack: Stack): string {

  const script = path.join(__dirname, '_fetch-aws-cdk-token-value.js');
  const children = stack.node.findAll().filter(c => CfnResource.isCfnResource(c) && stack.resolve(c.logicalId) === token.logicalId);
  const typeName = (children[0] as CfnResource).cfnResourceType;
  return execFileSync(process.execPath, [
    script,
    token.logicalId,
    token.attribute,
    typeName,
    stack.stackName,
  ], { encoding: 'utf-8' }).toString().trim();
}
