import { execFileSync } from 'child_process';
import * as path from 'path';
import { Token as AWSCDKToken, Stack as AWSCDKStack } from 'aws-cdk-lib';
// eslint-disable-next-line import/no-extraneous-dependencies
import { TerraformStack, Token as CDKTFToken, DefaultTokenResolver, StringConcat, Tokenization } from 'cdktf';
import { Lazy } from './lazy';

export function resolve(value: any, awscdkStack?: AWSCDKStack, cdktfStack?: TerraformStack): any {

  if (value == null) {
    return value;
  }

  // cdk8s token
  if (value instanceof Lazy) {
    const resolved = value.produce();
    return resolve(resolved, awscdkStack, cdktfStack);
  }

  if (awscdkStack && AWSCDKToken.isUnresolved(value)) {
    const resolved = awscdkStack.resolve(value);
    // TODO handle `Fn` functions.
    const token = parseAwsCdkToken(resolved);
    try {
      return fetchAwsCdkTokenValue(token, awscdkStack);
    } catch (error) {
      // maybe the CDK deployment didn't happen yet
      return value;
    }
  }
  if (cdktfStack && CDKTFToken.isUnresolved(value)) {
    const resolver = new DefaultTokenResolver(new StringConcat());
    const resolved = Tokenization.resolve(value, {
      resolver,
      scope: cdktfStack,
    });
    const token = parseCdktfToken(resolved);

    try {
      return fetchCdktfTokenValue(token, cdktfStack);
    } catch (error) {
      // maybe the CDKTF deployment didn't happen yet
      return value;
    }

  }

  // implicit token as generated by the cdk8s-cli (e.g IntOrString)
  if (typeof(value.resolve) === 'function') {
    const resolved = value.resolve();
    return resolve(resolved, awscdkStack, cdktfStack);
  }

  if (typeof(value) !== 'object') {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map(x => resolve(x, awscdkStack, cdktfStack));
  }

  const result: any = {};

  for (const [k, v] of Object.entries(value)) {
    result[k] = resolve(v, awscdkStack, cdktfStack);
  }

  return result;

}

interface AwsCdkToken {
  readonly logicalId: string;
  readonly attribute: string;
}

interface CdktfToken {
  readonly address: string;
  readonly attribute: string;
}

function parseAwsCdkToken(resolved: any): AwsCdkToken {
  const keys = Object.keys(resolved);
  if (keys.length > 1) {
    throw Error(`Token must only have 1 key: ${JSON.stringify(resolved)}`);
  }
  const key = keys[0];
  if (key === 'Ref') {
    return {
      attribute: key,
      logicalId: resolved[key],
    };
  }
  if (key === 'Fn::GetAtt') {
    const value = resolved[keys[0]];
    // TODO validate this is indeed an array of size 2
    return {
      attribute: value[1],
      logicalId: value[0],
    };
  }
  throw new Error(`Unexpected token: ${JSON.stringify(resolved)}`);
}

function parseCdktfToken(resolved: string): CdktfToken {
  // cdktf tokens are surrounded with ${}
  // TODO add more protections
  const parts = resolved.substring(2, resolved.length - 1).split('.');
  return {
    address: parts.slice(0, parts.length - 1).join('.'),
    attribute: parts.slice(-1)[0],
  };
}

function fetchAwsCdkTokenValue(token: AwsCdkToken, stack: AWSCDKStack): string {

  const script = path.join(__dirname, '_fetch-aws-cdk-token-value.js');
  return execFileSync(process.execPath, [
    script,
    token.logicalId,
    token.attribute,
    stack.stackName,
  ], { encoding: 'utf-8' }).toString().trim();
}

function fetchCdktfTokenValue(token: CdktfToken, stack: TerraformStack): string {

  const script = path.join(__dirname, '_fetch-cdktf-token-value.js');
  return execFileSync(process.execPath, [
    script,
    token.address,
    token.attribute,
    // TODO is this always the directory of the stack?
    stack.node.id,
  ], { encoding: 'utf-8' }).toString().trim();
}
